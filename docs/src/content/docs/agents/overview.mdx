---
title: Agents overview
description: An overview of agents
---

In the Multi-Agent Orchestrator, an agent is a fundamental building block designed to process user requests and generate a response. The `Agent` abstract class serves as the foundation for all specific agent implementations, providing a common structure and interface.

## Agent selection process

The Multi-Agent Orchestrator uses a [Classifier](/multi-agent-orchestrator/classifiers/overview), typically an LLM, to select the most appropriate agent for each user request.

At the heart of this process are the **agent descriptions**.
These descriptions are critical and should be as detailed and comprehensive as possible.

A well-crafted agent description:

- Clearly outlines the agent's capabilities and expertise
- Provides specific examples of tasks it can handle
- Distinguishes it from other agents in the system

The more detailed and precise these descriptions are, the more accurately the Classifier can route requests to the right agent. This is especially important in complex systems with multiple specialized agents.

For a more detailed explanation of the agent selection process, please refer to the [How it works section](/multi-agent-orchestrator/general/how-it-works) section in our documentation.

To optimize agent selection:
- Invest time in crafting thorough, specific agent descriptions
- Regularly review and refine these descriptions
- Use the framework's [agent overlap analysis](/multi-agent-orchestrator/advanced-features/agent-overlap) to ensure clear differentiation between agents

By prioritizing detailed agent descriptions and fine-tuning the selection process, you can significantly enhance the efficiency and accuracy of your Multi-Agent Orchestrator implementation.

## The Agent Abstract Class

The `Agent` class is an abstract base class that defines the essential properties and methods that all agents in the system must have. It's designed to be flexible, allowing for a wide range of implementations from simple API callers to complex LLM-powered conversational agents.

### Key Properties

- `name`: A string representing the name of the agent.
- `id`: A unique identifier for the agent, automatically generated from the name.
- `description`: A string describing the agent's capabilities and expertise.
- `save_chat`: A boolean indicating whether to save the chat history for this agent.
- `callbacks`: An optional `AgentCallbacks` object for handling events like new tokens in streaming responses.

Here's an example of the `Agent` abstract class structure:

import { Tabs, TabItem } from '@astrojs/starlight/components';

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    import { AgentOptions, Message } from './types';

    abstract class Agent {
      readonly name: string;
      readonly id: string;
      readonly description: string;
      readonly saveChat: boolean;
      readonly callbacks?: AgentCallbacks;

      constructor(options: AgentOptions) {
        this.name = options.name;
        this.id = options.name.toLowerCase().replace(/\s+/g, '-');
        this.description = options.description;
        this.saveChat = options.saveChat ?? true;
        this.callbacks = options.callbacks;
      }

      abstract processRequest(
        inputText: string,
        userId: string,
        sessionId: string,
        chatHistory: Message[],
        additionalParams?: Record<string, any>
      ): Promise<Message | AsyncIterable<any>>;
    }
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from abc import ABC, abstractmethod
    from typing import List, Dict, Union, AsyncIterable, Optional
    from .types import AgentOptions, Message, AgentCallbacks

    class Agent(ABC):
        def __init__(self, options: AgentOptions):
            self.name: str = options.name
            self.id: str = options.name.lower().replace(' ', '-')
            self.description: str = options.description
            self.save_chat: bool = options.save_chat if options.save_chat is not None else True
            self.callbacks: Optional[AgentCallbacks] = options.callbacks

        @abstractmethod
        async def process_request(
            self,
            input_text: str,
            user_id: str,
            session_id: str,
            chat_history: List[Message],
            additional_params: Optional[Dict[str, any]] = None
        ) -> Union[Message, AsyncIterable[any]]:
            pass
    ```
  </TabItem>
</Tabs>

### Abstract Method: process_request

The core functionality of any agent is encapsulated in the `process_request` method. This method must be implemented by all concrete agent classes:

<Tabs syncKey="runtime">
  <TabItem label="TypeScript" icon="seti:typescript" color="blue">
    ```typescript
    abstract processRequest(
      inputText: string,
      userId: string,
      sessionId: string,
      chatHistory: Message[],
      additionalParams?: Record<string, any>
    ): Promise<Message | AsyncIterable<any>>;
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    from abc import abstractmethod
    from typing import Union, AsyncIterable, Optional, Dict, List
    from multi_agent_orchestrator.types import ConversationMessage

    class Agent(ABC):
        @abstractmethod
        async def process_request(
            self,
            input_text: str,
            user_id: str,
            session_id: str,
            chat_history: List[ConversationMessage],
            additional_params: Optional[Dict[str, str]] = None
        ) -> Union[ConversationMessage, AsyncIterable[any]]:
            pass
    ```
  </TabItem>
</Tabs>

- `input_text`: The user's input or query.
- `user_id`: A unique identifier for the user.
- `session_id`: An identifier for the current conversation session.
- `chat_history`: A list of previous messages in the conversation.
- `additional_params`: Optional parameters for additional context or configuration. This is a powerful feature that allows for dynamic customization of agent behavior
  - It's an optional dictionary of key-value pairs that can be passed when calling `route_request` on the orchestrator.
  - These parameters are then forwarded to the appropriate agent's `process_request` method.
  - Custom agents can use these parameters to adjust their behavior or provide additional context for processing the request.

The method returns either a `ConversationMessage` for single responses or an `AsyncIterable` for streaming responses.

Example usage:

<Tabs syncKey="runtime">
  <TabItem label="TypeScript" icon="seti:typescript" color="blue">
    ```typescript
    // When calling routeRequest
    const response = await orchestrator.routeRequest(
      userInput,
      userId,
      sessionId,
      { location: "New York", units: "metric" }
    );

    // In a custom agent's processRequest method
    class WeatherAgent extends Agent {
      async processRequest(
        inputText: string,
        userId: string,
        sessionId: string,
        chatHistory: Message[],
        additionalParams?: Record<string, any>
      ): Promise<Message> {
        const location = additionalParams?.location || "default location";
        const units = additionalParams?.units || "metric";
        // Use location and units to fetch weather data
        // ...
      }
    }
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```python
    # When calling route_request
    response = await orchestrator.route_request(
        user_input,
        user_id,
        session_id,
        additional_params={"location": "New York", "units": "metric"}
    )

    # In a custom agent's process_request method
    class WeatherAgent(Agent):
        async def process_request(
            self,
            input_text: str,
            user_id: str,
            session_id: str,
            chat_history: List[ConversationMessage],
            additional_params: Optional[Dict[str, str]] = None
        ) -> ConversationMessage:
            location = additional_params.get('location', 'default location')
            units = additional_params.get('units', 'metric')
            # Use location and units to fetch weather data
            # ...
    ```
  </TabItem>
</Tabs>

### Agent Options

When creating a new agent, you can specify various options using the `AgentOptions` class:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    interface AgentOptions {
      name: string;
      description: string;
      modelId?: string;
      region?: string;
      saveChat?: boolean;
      callbacks?: AgentCallbacks;
    }
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from typing import Optional
    from dataclasses import dataclass
    from .types import AgentCallbacks

    @dataclass
    class AgentOptions:
        name: str
        description: str
        model_id: Optional[str] = None
        region: Optional[str] = None
        save_chat: Optional[bool] = None
        callbacks: Optional[AgentCallbacks] = None
    ```
  </TabItem>
</Tabs>

These options allow you to customize various aspects of the agent's behavior and configuration.

### Message Type

The `Message` type is used in the `processRequest` method and represents the structure of messages in the conversation:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    type Message = {
      role: 'user' | 'assistant' | 'system';
      content: Array<{ text: string }>;
    };
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from typing import List, TypedDict
    from enum import Enum

    class Role(Enum):
        USER = 'user'
        ASSISTANT = 'assistant'
        SYSTEM = 'system'

    class Content(TypedDict):
        text: str

    class Message(TypedDict):
        role: Role
        content: List[Content]
    ```
  </TabItem>
</Tabs>

### Using Additional Parameters

Agents can accept additional parameters to customize their behavior. Here's an example of a weather agent that uses additional parameters:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript
    class WeatherAgent extends Agent {
      async processRequest(
        inputText: string,
        userId: string,
        sessionId: string,
        chatHistory: Message[],
        additionalParams?: Record<string, any>
      ): Promise<Message> {
        const location = additionalParams?.location || 'default location';
        const units = additionalParams?.units || 'metric';
        
        // Simulated weather API call
        const weather = await this.getWeather(location, units);
        
        return {
          role: 'assistant',
          content: [{ text: `The weather in ${location} is ${weather.description}. Temperature: ${weather.temperature}°${units === 'metric' ? 'C' : 'F'}` }]
        };
      }

      private async getWeather(location: string, units: string) {
        // Simulated API call
        return { description: 'sunny', temperature: 25 };
      }
    }

    // Usage
    const weatherAgent = new WeatherAgent({
      name: 'Weather Agent',
      description: 'An agent that provides weather information'
    });

    const orchestrator = new Orchestrator();
    orchestrator.addAgent(weatherAgent);

    const response = await orchestrator.routeRequest(
      'What\'s the weather like?',
      'user123',
      'session456',
      { location: 'New York', units: 'metric' }
    );
    console.log(response);
    ```
  </TabItem>
  <TabItem label="Python">
    ```python
    from typing import Dict, Any, Optional
    from .agent import Agent
    from .types import Message, Role

    class WeatherAgent(Agent):
        async def process_request(
            self,
            input_text: str,
            user_id: str,
            session_id: str,
            chat_history: List[Message],
            additional_params: Optional[Dict[str, Any]] = None
        ) -> Message:
            location = additional_params.get('location', 'default location')
            units = additional_params.get('units', 'metric')
            
            # Simulated weather API call
            weather = await self.get_weather(location, units)
            
            return {
                'role': Role.ASSISTANT,
                'content': [{'text': f"The weather in {location} is {weather['description']}. Temperature: {weather['temperature']}°{'C' if units == 'metric' else 'F'}"}]
            }

        async def get_weather(self, location: str, units: str) -> Dict[str, Any]:
            # Simulated API call
            return {'description': 'sunny', 'temperature': 25}

    # Usage
    weather_agent = WeatherAgent(AgentOptions(
        name='Weather Agent',
        description='An agent that provides weather information'
    ))

    orchestrator = Orchestrator()
    orchestrator.add_agent(weather_agent)

    response = await orchestrator.route_request(
        'What\'s the weather like?',
        'user123',
        'session456',
        additional_params={'location': 'New York', 'units': 'metric'}
    )
    print(response)
    ```
  </TabItem>
</Tabs>

This example demonstrates how to create a custom agent that accepts additional parameters to customize its behavior.
